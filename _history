{"entries":[{"timestamp":1745284723138,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":3948,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":206,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1745284726617,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":152,"diffs":[[1,"namespace clouds {\n    enum WeatherType { Clear, Cloudy, Stormy }\n"]]},{"start1":67,"length1":124,"diffs":[[1,"    let cloudSprites: Sprite[] = []\n    let backgroundClouds: Sprite[] = []\n    let isDay = true\n    let transition = 0\n    let transitionSpeed = 0.01\n    let weather: WeatherType = WeatherType.Clear\n    let cycleDuration = 0\n    let transitionDir = 1\n"]]},{"start1":320,"length1":150,"diffs":[[1,"    //% block\n    export function createVolumetricClouds(count: number = 8, layers: number = 2): void {\n        perlin.init()\n        for (let i = 0; i < count; i++) {\n            const depth = i % layers\n            const s = sprites.create(generateCloudImage(depth), SpriteKind.create())\n            s.x = Math.randomRange(0, scene.screenWidth())\n            s.y = Math.randomRange(10 + depth * 10, 40 + depth * 10)\n            s.z = depth\n            s.vx = -((depth + 1) * 5) / 10\n            if (depth == 0) {\n                backgroundClouds.push(s)\n            } else {\n                cloudSprites.push(s)\n            }\n        }\n"]]},{"start1":959,"length1":46,"diffs":[[1,"        game.onUpdate(() => {\n            updateTransition()\n            for (let cloud of cloudSprites.concat(backgroundClouds)) {\n                cloud.x += cloud.vx\n                if (weather == WeatherType.Stormy) cloud.x += -1 // storm wind\n"]]},{"start1":1207,"length1":23,"diffs":[[1,"                if (cloud.x < -32) {\n                    cloud.x = scene.screenWidth() + 32\n                    cloud.y = Math.randomRange(10, 50)\n                    cloud.setImage(generateCloudImage(cloud.z))\n                }\n            }\n"]]},{"start1":1451,"length1":104,"diffs":[[1,"            // Flash lightning\n            if (weather == WeatherType.Stormy && Math.percentChance(0.5)) {\n                screen.setBrightness(255)\n                pause(30)\n                screen.setBrightness(isDay ? 100 : 40)\n            }\n        })\n    }\n"]]},{"start1":1713,"length1":80,"diffs":[[1,"    //% block\n    export function setDaytime(value: boolean): void {\n        isDay = value\n        transition = isDay ? 0 : 1\n        updateCloudImages()\n"]]},{"start1":1874,"length1":453,"diffs":[[1,"    //% block\n    export function toggleDayNightCycle(duration: number): void {\n        cycleDuration = duration\n        game.onUpdateInterval(cycleDuration, () => {\n            transitionDir = transitionDir * -1\n        })\n"]]},{"start1":2105,"length1":745,"diffs":[[1,"    //% block\n    export function setWeather(type: string): void {\n        switch (type.toLowerCase()) {\n            case \"clear\":\n                weather = WeatherType.Clear\n                break\n            case \"cloudy\":\n                weather = WeatherType.Cloudy\n                break\n            case \"stormy\":\n                weather = WeatherType.Stormy\n                break\n"]]},{"start1":2500,"length1":25,"diffs":[[1,"        updateCloudImages()\n"]]},{"start1":2535,"length1":93,"diffs":[[1,"    function updateTransition() {\n        if (cycleDuration > 0) {\n            transition += transitionSpeed * transitionDir\n            transition = Math.clamp(0, 1, transition)\n            screen.setBrightness(Math.map(transition, 0, 1, 100, 40))\n            updateCloudImages()\n"]]},{"start1":2826,"length1":20,"diffs":[[1,""]]},{"start1":2833,"length1":153,"diffs":[[1,"    function updateCloudImages() {\n        for (let cloud of cloudSprites.concat(backgroundClouds)) {\n            cloud.setImage(generateCloudImage(cloud.z))\n        }\n"]]},{"start1":3008,"length1":161,"diffs":[[1,"    function generateCloudImage(layer: number): Image {\n        const width = 32\n        const height = 16\n        let img = image.create(width, height)\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let n = perlin.noise(x * 0.1 + layer * 10, y * 0.1 + layer * 20)\n                let alpha = Math.floor(n * 4)\n                if (alpha > 0) {\n                    // Blend between day and night color\n                    let dayColor = alpha + 1\n                    let nightColor = 14 - alpha\n                    let color = Math.round(dayColor * (1 - transition) + nightColor * transition)\n"]]},{"start1":3659,"length1":142,"diffs":[[1,"                    // Storm darkening\n                    if (weather == WeatherType.Stormy) {\n                        color = Math.max(1, color - 2)\n                    }\n"]]},{"start1":3833,"length1":821,"diffs":[[1,"                    img.setPixel(x, y, color)\n                }\n"]]},{"start1":3921,"length1":0,"diffs":[[1,"        return img\n"]]},{"start1":3946,"length1":1,"diffs":[[1,"}\n"]]}]}]},{"timestamp":1745289047958,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]}]},{"timestamp":1745289061459,"editorVersion":"2.0.53","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":206,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1745284723137,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"clouds \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1745289041871,"editorVersion":"2.0.53","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"namespace clouds {\n    enum WeatherType { Clear, Cloudy, Stormy }\n\n    let cloudSprites: Sprite[] = []\n    let backgroundClouds: Sprite[] = []\n    let isDay = true\n    let transition = 0\n    let transitionSpeed = 0.01\n    let weather: WeatherType = WeatherType.Clear\n    let cycleDuration = 0\n    let transitionDir = 1\n\n    //% block\n    export function createVolumetricClouds(count: number = 8, layers: number = 2): void {\n        perlin.init()\n        for (let i = 0; i < count; i++) {\n            const depth = i % layers\n            const s = sprites.create(generateCloudImage(depth), SpriteKind.create())\n            s.x = Math.randomRange(0, scene.screenWidth())\n            s.y = Math.randomRange(10 + depth * 10, 40 + depth * 10)\n            s.z = depth\n            s.vx = -((depth + 1) * 5) / 10\n            if (depth == 0) {\n                backgroundClouds.push(s)\n            } else {\n                cloudSprites.push(s)\n            }\n        }\n\n        game.onUpdate(() => {\n            updateTransition()\n            for (let cloud of cloudSprites.concat(backgroundClouds)) {\n                cloud.x += cloud.vx\n                if (weather == WeatherType.Stormy) cloud.x += -1 // storm wind\n\n                if (cloud.x < -32) {\n                    cloud.x = scene.screenWidth() + 32\n                    cloud.y = Math.randomRange(10, 50)\n                    cloud.setImage(generateCloudImage(cloud.z))\n                }\n            }\n\n            // Flash lightning\n            if (weather == WeatherType.Stormy && Math.percentChance(0.5)) {\n                screen.setBrightness(255)\n                pause(30)\n                screen.setBrightness(isDay ? 100 : 40)\n            }\n        })\n    }\n\n    //% block\n    export function setDaytime(value: boolean): void {\n        isDay = value\n        transition = isDay ? 0 : 1\n        updateCloudImages()\n    }\n\n    //% block\n    export function toggleDayNightCycle(duration: number): void {\n        cycleDuration = duration\n        game.onUpdateInterval(cycleDuration, () => {\n            transitionDir = transitionDir * -1\n        })\n    }\n\n    //% block\n    export function setWeather(type: string): void {\n        switch (type.toLowerCase()) {\n            case \"clear\":\n                weather = WeatherType.Clear\n                break\n            case \"cloudy\":\n                weather = WeatherType.Cloudy\n                break\n            case \"stormy\":\n                weather = WeatherType.Stormy\n                break\n        }\n        updateCloudImages()\n    }\n\n    function updateTransition() {\n        if (cycleDuration > 0) {\n            transition += transitionSpeed * transitionDir\n            transition = Math.clamp(0, 1, transition)\n            screen.setBrightness(Math.map(transition, 0, 1, 100, 40))\n            updateCloudImages()\n        }\n    }\n\n    function updateCloudImages() {\n        for (let cloud of cloudSprites.concat(backgroundClouds)) {\n            cloud.setImage(generateCloudImage(cloud.z))\n        }\n    }\n\n    function generateCloudImage(layer: number): Image {\n        const width = 32\n        const height = 16\n        let img = image.create(width, height)\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                let n = perlin.noise(x * 0.1 + layer * 10, y * 0.1 + layer * 20)\n                let alpha = Math.floor(n * 4)\n                if (alpha > 0) {\n                    // Blend between day and night color\n                    let dayColor = alpha + 1\n                    let nightColor = 14 - alpha\n                    let color = Math.round(dayColor * (1 - transition) + nightColor * transition)\n\n                    // Storm darkening\n                    if (weather == WeatherType.Stormy) {\n                        color = Math.max(1, color - 2)\n                    }\n\n                    img.setPixel(x, y, color)\n                }\n            }\n        }\n        return img\n    }\n}\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"clouds \",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1745289061464}